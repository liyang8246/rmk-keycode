const fs = require('fs');
const path = require('path');

const rustFilePath = path.join(__dirname, '../lib/rmk/src/keycode.rs');
const tsFilePath = path.join(__dirname, '../src/keycodes.ts');

fs.readFile(rustFilePath, 'utf8', (err, data) => {
    if (err) {
        console.error('Error reading Rust file:', err);
        return;
    }

    const keycodeEnumRegex = /pub enum KeyCode \{\n([\s\S]*?)\n\}/;
    const match = data.match(keycodeEnumRegex);

    if (!match) {
        console.error('Could not find KeyCode enum in the Rust file.');
        return;
    }

    const enumContent = match[1];
    const lines = enumContent.split('\n');

    let tsContent = `// This file is auto-generated by scripts/generate-keycodes.js\n\n`;
    tsContent += `export enum KeyCode {\n`;

    lines.forEach(line => {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith('///') || trimmedLine.length === 0 || trimmedLine.startsWith('#[') || trimmedLine.startsWith('//')) {
            return; // Skip comments, empty lines, and attribute macros
        }

        const parts = trimmedLine.split(' = ');
        if (parts.length === 2) {
            let name = parts[0].trim();
            const value = parts[1].replace(/,$/, '').trim(); // Remove trailing comma

            // If the name contains a comment, remove it
            const commentIndex = name.indexOf('///');
            if (commentIndex !== -1) {
                name = name.substring(0, commentIndex).trim();
            }

            tsContent += `  ${name} = ${value},\n`;
        }
    });

    tsContent += `}\n`;

    const outputDir = path.dirname(tsFilePath);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    fs.writeFile(tsFilePath, tsContent, 'utf8', (err) => {
        if (err) {
            console.error('Error writing TypeScript file:', err);
            return;
        }
        console.log('Successfully generated src/keycodes.ts');
    });
});